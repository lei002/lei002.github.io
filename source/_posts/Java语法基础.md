---
abbrlink: 1
---
# Java语法基础

[TOC]



## 关键字和保留字

### 关键字（Key Word）

> 什么是关键字？

- 关键字就是被Java语法赋予特定含义的单词

> 关键字有什么作用？

- 关键字对编译器有特殊意义，他们用来表示一种数据类型或者表示程序的结构

- class

> 关键字有什么特点？

- 关键字必须全部小写



### 保留字（Reserve Word）

> 什么是保留字？

- 保留字是对当前版本的Java并没有特殊含义的单词
  - 但是，以后的版本可能会变成具有特殊含义的单词，将其升级为关键字
  - 即便以后也不打算升级为关键字，但是Java官方认为你不应该在Java代码中使用的单词

> 有哪些保留字？

- const
- goto

### 关键字和保留字的语法意义

- **关键字和保留字均不能用作变量名、方法名、类名、包名和参数**
- 由于大家使用比较高级的集成开发环境，关键字是有特殊颜色标记的



> 课堂抽奖

以下哪些是关键字？

class，HelloWorld，public，static，void，main，String，System



### Java关键字大全

| 关键字                       | 含义                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| abstract                     | 表明类或者成员方法具有抽象属性                               |
| assert                       | 用来进行程序调试                                             |
| boolean                      | 基本数据类型之一，布尔类型                                   |
| break                        | 提前跳出一个块                                               |
| byte                         | 基本数据类型之一，字节类型                                   |
| case                         | 用在switch语句之中，表示其中的一个分支                       |
| catch                        | 用在异常处理中，用来捕捉异常                                 |
| char                         | 基本数据类型之一，字符类型                                   |
| class                        | 类                                                           |
| <font color=red>const</font> | 保留关键字，没有具体含义                                     |
| continue                     | 回到一个块的开始处                                           |
| default                      | 默认，例如，用在switch语句中，表明一个默认的分支             |
| do                           | 用在do-while循环结构中                                       |
| double                       | 基本数据类型之一，双精度浮点数类型                           |
| else                         | 用在条件语句中，表明当条件不成立时的分支                     |
| enum                         | 枚举                                                         |
| extends                      | 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口   |
| final                        | 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量 |
| finally                      | 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块     |
| float                        | 基本数据类型之一，单精度浮点数类型                           |
| for                          | 一种循环结构的引导词                                         |
| <font color=red>goto</font>  | 保留关键字，没有具体含义                                     |
| if                           | 条件语句的引导词                                             |
| implements                   | 表明一个类实现了给定的接口                                   |
| import                       | 表明要访问指定的类或包                                       |
| instanceof                   | 用来测试一个对象是否是指定类型的实例对象                     |
| int                          | 基本数据类型之一，整数类型                                   |
| interface                    | 接口                                                         |
| long                         | 基本数据类型之一，长整数类型                                 |
| native                       | 用来声明一个方法是由与计算机相关的语言(如C/C++/FORTRAN语言)实现的 |
| new                          | 用来创建新实例对象                                           |
| package                      | 包                                                           |
| private                      | 一种访问控制方式:私用模式                                    |
| protected                    | 一种访问控制方式:保护模式                                    |
| public                       | 一种访问控制方式:共用模式                                    |
| return                       | 从成员方法中返回数据                                         |
| short                        | 基本数据类型之一,短整数类型                                  |
| static                       | 表明具有静态属性                                             |
| strictfp                     | 用来声明FP_strict(单精度或双精度浮点数)表达式遵循IEEE 754算术规范 |
| super                        | 表明当前对象的父类型的引用或者父类型的构造方法               |
| switch                       | 分支语句结构的引导词                                         |
| synchronized                 | 表明一段代码需要同步执行                                     |
| this                         | 指向当前实例对象的引用                                       |
| throw                        | 抛出一个异常                                                 |
| throws                       | 声明在当前定义的成员方法中所有需要抛出的异常                 |
| transient                    | 声明不用序列化的成员域                                       |
| try                          | 尝试一个可能抛出异常的程序块                                 |
| void                         | 声明当前成员方法没有返回值                                   |
| volatile                     | 表明两个或者多个变量必须同步地发生变化                       |
| while                        | 用在循环结构中                                               |



## 标识符（Identifier）

> 什么是标识符？

- 标识符是给包，类，接口，方法，变量等起名字时使用的字符序列



### 虚假的标识符命名规则（语法）

> 标识符的语法规则是什么？

- 标识符的组成
  - 数字（0~9）
  - 字母（A~Z 和 a~z）
  - 美元符号（$）
  - 下划线（_）
  - Unicode 字符集中符号大于 0xC0 的所有符号
- 标识符的开头
  - 字母（A~Z 和 a~z）
  - 下划线（_）
  - 美元符号（$）
  - Unicode 字符集中符号大于 0xC0 的所有符号
- 注意事项
  - 标识符不能以数字开头
  - 不能是Java中的关键字和保留字
  - 标识符区分大小写



> 课堂抽奖

以下标识符命名合法的有哪些？

HelloWorld，_985，$bS5_c7，class，Class ，DataClass#，98.3，Hello  World





### 真实的标识符组成规则（基于语法的约定）

以上只是语法范畴的标识符规则，但就像人可以起名叫“张三，李四”，但几乎没人这么做一样

<font color=red>在符合语法的前提下</font>，标识符还有一套约定俗成的命名规则，详见《阿里巴巴Java开发规范》

> 真实的标识符组成规则

- 符合语法
- 只能用英文字母、数字（下划线、美元符号几乎不使用）
- 包命名标识符
  - Java中的包类似操作系统中的文件夹
  - 包的命名，以反转公司域名为规范
  - 包名应该全部小写
  - 多级包名以点（.）分隔
- 类、接口等命名标识符
  - 大驼峰命名法
- 变量、方法的命名标识符
  - 小驼峰命名法
- 常量的命名标识符
  - 全部大写（建议）
  - 多个单词之间用下划线（_）隔开



> 给人起名字也追求好听吉祥，标识符起名也有自己的追求

- 核心追求是“见名知意”，应该赋予标识符一个有意义、有用途的名字





### 驼峰命名法

#### 小驼峰式命名法（lower camel case）

- 多个单词组合成一个字符串
  - 第一个单词的首字母**小写**
  - 从第二个单词开始，首字母都要大写
- 例如：myName，myFirstJavaProgram



#### 大驼峰式命名法（upper camel case）

- 多个单词组合成一个字符串
  - 第一个单词的首字母**大写**
  - 从第二个单词开始，首字母都要大写
- 例如：MyName，MyFirstJavaProgram





## 注释（comment）

> 什么是注释？

- 注释是可以嵌入到Java代码的任何位置的，一种解释说明性的文字

> 注释有什么作用？

- 方便自己写代码的时候，记录程序的信息
- 增加代码的可读性
  - 过段时间后，自己也能很快想起来，自己写的代码是干什么的
  - 最重要的，方便别人能看懂自己的代码
- 写注释可以增加自己写代码的逻辑性
  - 编码之前先用注释，标注好需要做的事情，先搞明白思路，再写代码
  - 编码实际上就是思想的体现
- 注释也可以作为一种比较简单但十分好用有效的，debug的方式
  - 将可能出错的代码注释掉，再运行程序，直到找出bug

> 注释的语法

Java支持三种注释的语法格式

- 单行注释

  ```Java
  //注释的文字
  ```

- 多行注释

  ```java 
  /*
  注释的文字
  */
  ```

- 文档注释

  ```java 
  /**
  注释的文字
  */
  ```

> 注释的使用注意事项

- 多行注释和文档注释不要嵌套使用
- 注释不参与编译，编译器会自动丢掉代码中的注释部分
- JDK中提供了**javadoc.exe**工具，用于将文档注释输出到一个HTML文件中



## 常量与变量

> 程序运行中，内存中有很多数据参与运算
>
> - Java使用变量来存储这些数据
> - 程序运行中，值不变的变量就是常量



### 常量（constant）

>什么是常量？

- 在程序运行过程中，其值不会发生改变的量

>常量有哪些分类？

- 字面值常量（**literal**）
  - 字符串常量：双引号引起来的内容
    - “Hello World！”
  - 整数常量：所有的整数
    - 1，2，3
  - 小数常量：所有的小数
    - 1.1，1.2
  - 字符常量：单引号引起来的内容
    - 'W'，'E'，
  - 布尔常量
    - 只有true和false
  - 空常量
    - 只有null
- 自定义常量（面向对象详细讲）



### 变量（variable）

> 什么是变量？

- 程序运行期间，其值在某个范围内，可能会发生改变的量
- 可以将变量理解成未知数X

> 怎么定义一个能够使用的变量

- 两步走：先声明变量，再初始化变量（赋值）



#### 声明（declaration）变量

> 什么是声明变量？

- 告诉编译器，变量的数据类型，变量的名字

> 声明变量的语法

```Java
数据类型 变量名;
```

> 课堂抽奖

声明后的变量能够直接使用吗？







#### 初始化（initialization）变量

> 什么是初始化变量

- 就是给变量赋值，声明一个变量后，必须由程序员显式的进行赋值操作，这个变量才能够使用

> 初始化变量的语法

```Java
变量名 = 变量值;
```

声明和初始化可以合起来

```
数据类型 变量名 = 变量名;
```



#### 使用变量的注意事项

- 变量有效的范围，这个范围通常用{}来界定，同样一个{}不能有同名变量
- 变量必须显式初始化，否则只能看不能使用
- 一行一个语句可以定义多个同数据类型的变量，用逗号隔开
  - 但是一行定义多个变量会影响代码的阅读性，一般不要一行定义多个变量





## 基本数据类型和引用数据类型

Java是强类型语言，每一个变量都必须有它的数据类型，并且变量之间不能随便转换数据类型

主流的语言大多都是强类型 C、C++、Java、python

弱类型语言

PHP

> 什么是数据类型？

- 数据类型，表示的是一个数据集合和基于该数据集合的一组合法操作

> 数据类型怎么分类？

- 基本数据类型：JDK默认提供
- 引用数据类型
  - 类
  - 接口
  - ....



### 基本数据类型（base date type）

> 有哪些基本数据类型？

> 四类八种

- 整型
  - byte：字节，1个字节空间
  - short：短整型，占2个字节空间
  - int：整型，占4个字节空间
  - long：长整型，占8个字节空间
  - 注意：Java当中的整数字面值常量，默认当作int处理
    - 如果你想要一个整数字面值常量数据类型为long，需要在后缀上加l或L，推荐L
- 浮点型
  - float：单精度浮点型，占4个字节
  - double：双精度浮点型，占8个字节
  - 注意：Java当中的浮点数，默认当作double处理
    - 如果你想要一个浮点数字面值常量数据类型为float，需要在后缀上加f或F，推荐
- 字符类型
  - char：占4个字节，表示单个字符
- 布尔类型
  - boolean：具体占多少内存，了解即可
    - 根据JVM规范，在内存中boolean当作int处理，占4个字节
    - boolean数组当成byte数组处理，一个boolean元素占1个字节



#### 基本数值类型的取值范围

| 基本数据类型 | 字节长度 | 大小（位） | 最小值 | 最大值 | 取值范围                                                  |
| ------------ | -------- | ---------- | ------ | ------ | --------------------------------------------------------- |
| **byte**     | 1字节    | 8bit       | -2^7   | 2^7-1  | -128 ~ 127                                                |
| **short**    | 2字节    | 16bit      | -2^15  | 2^15-1 | -32768 ~ 32767                                            |
| **int**      | 4字节    | 32bit      | -2^31  | 2^31-1 | -2147483648 ~ 2147483647（21亿出头）                      |
| **long**     | 8字节    | 64bit      | -2^63  | 2^63-1 | -9223372036854774808 ~ 9223372036854774807（大概922亿亿） |
| **float**    | 4字节    | 32bit      | -      | -      | -3.403E38~3.404E38（有效位数7~8位）                       |
| **double**   | 8字节    | 64bit      | -      | -      | -1.798E308~1.798E308（有效数字16~17位）                   |



####  浮点型的精度问题

> 什么是精度问题？
>
> 计算的结果的数据类型，或者新的数据类型无法容纳全部的数据，导致部分信息被截断丢失，数据失真
>
> 专业名词就叫做“精度丢失”



> 经典的案例

- 计算10/3
- 计算1-0.9

> - 正数十进制转换成二进制，除2直到商为0，取余数倒过来
>
> - 负数十进制转换成二进制，先算出正数的二进制数,取反+1
>
> - 正小数转换成二进制，用小数部分乘以2，取结果的整数部分(必然是1或者0)，
>   - 然后小数部分继续乘2
>   -  直到小数部分为0,或者已经达到了最大的位数
>   - 最终的结果（0.开头）正序排列

结论：浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差，生产环境慎用浮点数进行计算

最好的解决办法是用BigDecimal 替代float和double进行浮点数计算











### 引用数据类型（reference）

> 碍于知识点的限制，目前只要知道字符串（String）是一种引用数据类型即可
>
> String属于引用数据类型中的类





### 基本数据类型的数据类型转换（conversion）

> 什么是数据类型转换呢？

- Java是强类型语言，变量一旦声明后，数据类型不会轻易改变，但也并非完全不可能改变
- 我们将Java中变量的数据类型由某一种转换为另一种，这个过程叫做数据类型转换

> 数据类型转换的分类

- 自动类型转换，也叫向上转型
  - 向上转型只是自动类型转换的一种说法，这种说法只针对引用数据类型
- 强制类型转换，也叫向下转型
  - 向下转型只是自动类型转换的一种说法，这种说法只针对引用数据类型



#### 基本数据类型的自动类型转换（automatic）

> 什么是自动类型转换？

- 数据类型无需程序员操作，由系统自动转换

> 基本数据类型的自动类型转换的规则
>
> “小取值范围”转换为“大取值范围”发生自动类型转换（浮点数都比long取值范围大）

- byte、short、char之间不互相转换，一旦之间发生运算，一律自动转换为int进行运算，结果是int
- byte、short、char任一数据类型与int进行计算，一律自动转换为int进行计算，结果是int
- byte、short、char、int任一数据类型与long进行计算，一律自动转换为long进行计算，结果是long
- byte、short、char、int、long任一数据类型与float进行计算，一律自动转换为float进行计算，结果是float
- byte、short、char、int、long、float任一数据类型与double进行计算，一律自动转换为double进行计算，结果是double

> 精度问题
>
> “小容量”不一定是“小取值范围”——所有浮点类型都比long取值范围大
>
> 但是由于浮点数本身的问题，整型的内存表示方式也和浮点型完全不同，很容易产生精度丢失

- 当int、long（4字节，8字节）自动转换成float（4字节）时，可能会有精度损失
- 当long自动转换成double（8字节）时，也可能产生精度损失
- 不要用浮点型计算小数，除非对精度十分不敏感



![image-20210101011533113](../../../../markdown_picture/自动类型转换中的精度丢失-1610771799581.png)



#### 基本数据类型的强制类型转换（cast）

> 什么是强制类型转换

- 数据类型的转换需要程序员显式操作，否则报错

> 什么时候需要强制类型转换

- 在特别有必要的情况下，把一个占内存大的数据类型，转换成小的数据类型，比如int---->byte

> 语法

```java
目标数据类型 变量名 = (目标数据类型)(被转换的变量变量名);
```

> 精度问题

- 强制类型转换，大变小，精度损失是很常见的
- 强烈建议，如果不是不进行强制类型转换，程序就GG，不要使用强制类型转换，稍有不慎会导致bug
- 进行强制类型转换，要严格考量，数据类型的取值范围，像(byte)200这种行为是很滑稽的

> 补充

- boolean类型和其他数据类型之间不能通过强制类型转换语法直接转换



```
基本数据类型的类型转换，总结出规律
1，八种基本数据类型中，只有boolean类型不能直接进行类型转换，其他七种都可以互相转换
2，byte、short、char使用的时候尤其注意取值范围，若参与运算都会自动提升到int
3，“小取值范围”--->“大取值范围”称之为自动类型转换，排序是
	byte < short(char) < int < long < float < double
4，“大取值范围”--->“小取值范围”称之为强制类型转换，必须要显式处理，否则报错
	强制类型转换，很容易精度丢失，慎用
5，多种数据类型混合在一起进行运算，先全部提升为“最大取值范围”的数据类型，再进行计算
6，不同的数据类型，不能够直接运算
```





>小练习1
>
>​     byte b1 = 1, b2 = 2, b;
>
>​     b = b1+ b2;
>
>​     b= 1 + 2;
>
>​     哪句是编译失败的呢？为什么呢？



>小练习2
>
>​     byte b = 130;
>
>​     这句代码有没有问题？
>
>​	如有问题，咋整？



> 小练习3
>
> 请写出下列程序结果
>
> System.out.println('a');
>
> System.out.println('a'+1);
>
> System.out.println("hello"+'a'+1);
>
> System.out.println('a'+1+"hello");
>
> System.out.println("5+5"+5+5);
>
> System.out.println(5+5+"=5+5");



补充：

> 有符号的数据表示法——原码，反码，补码

计算机中的数据是二进制的，不像生活中用符号表示负数一样那么简单，在计算机中，有符号数的表示分为三种

<font color=red>注意：所有的数据运算都是采用补码形式进行</font>

- 原码
  - 有效数字是其绝对值的二进制表示
  - 最高位负数是0，正数是1
  - 有效数字和最高位之间用0补充
  - 除了最高位符号位外，其余位置都是数值位
- 反码
  - 正数的反码与原码相同
  - 负数的反码是对其原码逐位取反，符号位除外
- 补码
  - 正数的补码与原码相同
  - 负数的补码是在其反码上加1
  - 反码+1=补码
  - 反码=补码-1



附录：

> ASCII码表

| ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 |
| :------ | :------- | :------ | :------- | :------ | :------- | :------ | :------- |
| 0       | NUT      | 32      | (space)  | 64      | @        | 96      | 、       |
| 1       | SOH      | 33      | !        | 65      | A        | 97      | a        |
| 2       | STX      | 34      | "        | 66      | B        | 98      | b        |
| 3       | ETX      | 35      | #        | 67      | C        | 99      | c        |
| 4       | EOT      | 36      | $        | 68      | D        | 100     | d        |
| 5       | ENQ      | 37      | %        | 69      | E        | 101     | e        |
| 6       | ACK      | 38      | &        | 70      | F        | 102     | f        |
| 7       | BEL      | 39      | ,        | 71      | G        | 103     | g        |
| 8       | BS       | 40      | (        | 72      | H        | 104     | h        |
| 9       | HT       | 41      | )        | 73      | I        | 105     | i        |
| 10      | LF       | 42      | *        | 74      | J        | 106     | j        |
| 11      | VT       | 43      | +        | 75      | K        | 107     | k        |
| 12      | FF       | 44      | ,        | 76      | L        | 108     | l        |
| 13      | CR       | 45      | -        | 77      | M        | 109     | m        |
| 14      | SO       | 46      | .        | 78      | N        | 110     | n        |
| 15      | SI       | 47      | /        | 79      | O        | 111     | o        |
| 16      | DLE      | 48      | 0        | 80      | P        | 112     | p        |
| 17      | DCI      | 49      | 1        | 81      | Q        | 113     | q        |
| 18      | DC2      | 50      | 2        | 82      | R        | 114     | r        |
| 19      | DC3      | 51      | 3        | 83      | S        | 115     | s        |
| 20      | DC4      | 52      | 4        | 84      | T        | 116     | t        |
| 21      | NAK      | 53      | 5        | 85      | U        | 117     | u        |
| 22      | SYN      | 54      | 6        | 86      | V        | 118     | v        |
| 23      | TB       | 55      | 7        | 87      | W        | 119     | w        |
| 24      | CAN      | 56      | 8        | 88      | X        | 120     | x        |
| 25      | EM       | 57      | 9        | 89      | Y        | 121     | y        |
| 26      | SUB      | 58      | :        | 90      | Z        | 122     | z        |
| 27      | ESC      | 59      | ;        | 91      | [        | 123     | {        |
| 28      | FS       | 60      | <        | 92      | /        | 124     | \|       |
| 29      | GS       | 61      | =        | 93      | ]        | 125     | }        |
| 30      | RS       | 62      | >        | 94      | ^        | 126     | `        |
| 31      | US       | 63      | ?        | 95      | _        | 127     | DEL      |

